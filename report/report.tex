\documentclass{theme}


\misc{Homomorphic Encryption via Ring Learning With Errors (RLWE)}
\due{May 12th, 2024}

\usepackage[outputdir=../../]{minted}

\course{MATH 1580 - Spring 2024}{Cryptography}{Professor Vogt}

% Add bibliography
\usepackage[backend=biber]{biblatex}
\addbibresource{references.bib}

\input{commands}

\newcommand{\Enc}{\text{Enc}}
\newcommand{\Dec}{\text{Dec}}
\newcommand{\innerprod}[1]{\langle #1 \rangle}

\begin{document}

\section{Introduction}

Homomorphic encryption is an important cryptographic primitive that is necessary to support modern cryptographic protocols, such as anonymous voting. Some constructions of such a scheme are complicated and unintuitive. However, recent constructions relying on the Ring Learning With Errors (RLWE) problem provide reasonably concise and palatable constructions by relying on algebraic ring structures and computation therein.

This report will discuss the background and context for such a scheme (called BFV), and walk through a sample implementation in Python.
\footnote{Disclaimer: I was first exposed to this scheme and the RLWE problem in CSCI1515 (Applied Cryptography). However, the presentation was incredibly brief and didn't give any mathematical background on the construction, and we later used a library implementation as a black-box to construct other protocols. The content in the project is completely disjoint from that exposure, including both the mathematical background and the custom implementation.}

\section{Background}

Let $\mc{K_S}, \mc{K_P}, \mc{M}, \mc{C}$ represent the secret key space, public key space, message space, and ciphertext spaces of an encryption scheme, respectively.

We recall from class that a \textit{ring} is a mathematical structure

\section{Homomorphic Encryption}

When we say that an encryption scheme is \textit{homomorphic}, what we really mean is that we are able to perform some binary operation $S_C: (C,C) \to C$ on encrypted ciphertexts that corresponds to some operation $S_M: (M, M) \to M$ on the original messages \cite{fhe}.

An intuitive example could be a scheme where adding two ciphertexts $c_1 + c_2$ results in a ciphertext that is a valid encryption of the \textit{sum} of the original messages $m_1,m_2$, such that only the sum $m_1 + m_2$ is revealed when the quantity $c_1 + c_2$ is decrypted. Importantly, this cannot reveal \textit{anything about the original ciphertexts themselves} (other than what is discernable from the operation itself).

A more precise description of a homomorphic encryption scheme is as follows:

\begin{ndefinition}[Definition (Homomorphic Encryption)]
    An encryption scheme $E = (\Enc_E, \Dec_E)$ consisting of encryption and decryption functions is \textit{homomorphic} for an operator $S = (S_M, S_C)$ if for any two messages $m_1, m_2 \in \mc{M}$, public key $k_p \in \mc{K_P}$, and secret key $k_s \in \mc{K_S}$, the following is satisfied:

    \begin{equation}
        \Dec_E\p{k_s, S_C(\Enc_E(k_p, m_1), \Enc_E(k_p, m_2))} = S_M(m_1, m_2)
    \end{equation}
\end{ndefinition}

An important note is that the operations $S_C$ and $S_M$ are not necessarily (and are generally not) the same. For instance, it is possible that $S_C(c_1, c_2) = c_1 \cdot c_2$ (multiplying the ciphertexts) whereas the effect on the messages is addition: $S_M(m_1, m_2) = m_1 + m_2$ (adding the underlying messages). In other schemes, including the LWE scheme that we will discuss later, these functions get more complicated.

This definition is somewhat specific to work with the system we will discuss later, as certain homomorphic schemes can require additional parameters to be passed to the homomorphic operation $S_C$, such as the public key of the scheme.

A more ideal version of this ciphertext malleability is to allow for computation of arbitrary functions (circuits) on any number of ciphertexts. This is generally referred to as \textit{fully homomorphic encryption (FHE)} (CITATION). This is because so long as we can multiply and add ciphertexts, we can compute any arithmetic function (by approximating it with a circuit of addition and multiplication operations). Note that we get

The variant that we will discuss later is a \textit{somewhat homomorphic encryption (SHE)} scheme, which allows for a fixed number of operations to be computed on a given ciphertext. These schemes are less expressive than FHE schemes, but are much easier to implement.

\subsection{Example: Diffie-Hellman}

One illustrative example of homomorphic encryption is actually the Diffie-Hellman encryption scheme. If there are two encrypted messages $c_1 = (g^{r_1}, h^{r_1} m_1)$, and $c_2 = (g^{r_2}, h^{r_2} m_2)$, then we see that we get:

\begin{align}
    S_C(c_1, c_2) & = c_1 \cdot c_2                                          \\
                  & = (g^{r_1} \cdot g^{r_2}, h^{r_1} m_1 \cdot h^{r_2} m_2) \\
                  & = (g^{r_1 + r_2}, h^{r_1 + r_2} m_1 \cdot m_2)
\end{align}

Note that we're basically just doing pointwise multiplication within the tuple ciphertext. Importantly, since $r_1, r_2$ are randomly chosen from $\Z_q$, the quantity $r_1 + r_2$ is also completely random. This means that this is the same as an encryption of the quantity $m_1 \cdot m_2$, the product of the original messages.

Unfortunately, this example does not suffice for \textit{fully} homomorphic encryption, because it only supports a single operation on the message space (multiplication), so we cannot use this for arbitrary computation.

\subsection{Applications of Homomorphic Encryption}

In practice, homomorphic encryption is an incredibly versatile tool, which has a variety of use cases:

\begin{enumerate}
    \item \textbf{Anonymous Voting}: Say some government or organization wanted to tally votes for an election
    \item \textbf{Healthcare Statistics}:
\end{enumerate}

\section{Ring Learning With Errors (RLWE)}

The Ring Learning With Errors (RLWE) problem is a variant of the Learning With Errors (LWE) problem that is used to construct homomorphic encryption schemes. The constructs required for these schemes are generally a security parameter $n$ (which vaguely describes the hardness of the protocol, such that breaking the protocol is can only be achieved with $2^n$ operations), a modulus $q$ (which is the modulus of the ring that we are working in).

For this scheme, we will rely on the rings of the form $R_q = \Z_q[x]/(x^m + 1)$, which represent polynomials with integer coefficients modulo $q$ (aka the coefficients lie in $\Z_q$) modulo the polynomial $x^m + 1$ (roughly meaning that they have degree less than $m$). Although rings are outside the exact scope of this class (as well as the notion of modulo by ideals), these are details not directly relevant to the construction of the encryption scheme.

We also require a noise distribution $\chi$ which produces random element $e \in \R_q$ that is \textit{small}, in the sense that has high probability of being less than some bound $B$, which we will discuss later.

The RLWE problem is then defined as follows :

\section{Implementation}



\section{Conclusion}

% Add bibliography

\printbibliography

\end{document}